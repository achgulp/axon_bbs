Axon BBS - Architectural Blueprint & Developer Guide
1. Guiding Philosophy
The primary goal of this architecture is to achieve high modularity and low coupling. As the project grows, it is critical to ensure that a developer can work on one feature (e.g., Private Messaging) without needing to understand the inner workings of another (e.g., the Applet Framework).

This blueprint outlines a refactoring from the current structure into a domain-driven design, where the application is split into self-contained features.

2. Backend Architecture: Feature-Based Apps
The backend will be refactored from two large apps (core and api) into several smaller, feature-focused Django apps.

App Responsibilities:
core (The Foundation): This app is significantly slimmed down. It will only contain models and services that are truly universal and used by nearly every other part of the system.

Models: User, TrustedInstance, FileAttachment.

Services: BitSyncService, SyncService, EncryptionUtils.

accounts (New App): Handles everything related to user identity, profiles, and authentication.

Models: BannedPubkey, IgnoredPubkey, Alias.

Views: LoginView, RegisterView, UserProfileView, UnlockIdentityView.

Services: IdentityService, AvatarGenerator.

messaging (New App): Manages all public and private communications.

Models: MessageBoard, Message, PrivateMessage.

Views: MessageListView, PostMessageView, SendPrivateMessageView.

Services: (Could include future services like message formatting or spam detection).

applets (New App): Contains all logic for the applet framework, including games and viewers.

Models: Applet, AppletCategory, AppletData, HighScore.

Views: AppletListView, GetSaveAppletDataView, HighScoreListView.

Services: HighScoreService, OverlordAgentService, etc.

federation (New App): Dedicated to handling inter-server communication and moderation actions.

Models: FederatedAction, ModerationReport.

Views: SyncView, BitSyncChunkView, ModeratorQueueView.

Services: ModeratorAgentService.

Backend Communication Rules:
Primary Interface: Direct Python Calls: Since all apps run within the same Django project, the primary way they communicate is by importing each other's functions and classes. This is fast and simple. A view in the messaging app can directly import and use a model from the accounts app.

Secondary Interface: Django Signals: For highly decoupled actions, use Django Signals. For example, when a new Message is saved in the messaging app, it could send a message_posted signal. A separate achievements app could listen for this signal to award a "First Post!" badge, without the messaging app ever knowing about achievements.

3. Frontend Architecture: Decomposed Components
The frontend will be refactored to break down large, multi-purpose components into smaller, single-responsibility components.

The "Smart" and "Dumb" Component Pattern:
Container (Smart) Components: Their job is to manage state and logic. They fetch data, handle user input, and pass data down to their children. Example: MessageListContainer.js would fetch the list of messages and applets.

Presentational (Dumb) Components: Their job is to render UI. They receive data as props and display it. They are simple, reusable, and easy to test. Example: MessageTable.js would receive a list of messages and just render the table rows.

Key Refactoring Targets:
MessageList.js will be broken into:

MessageListContainer.js (Handles data fetching and state)

MessageTable.js (Displays the list of messages)

MessageDetailView.js (Displays a single selected message)

AttachmentRenderer.js (Handles the logic for finding and displaying viewer applets for attachments)

PostForm.js (The component for creating a new post)

apiClient.js will become more structured:

We will create a structured API client to abstract away URL endpoints.

Before: apiClient.get(\/api/boards/${board.id}/messages/`)`

After: apiClient.messaging.getMessagesForBoard(board.id)

This centralizes all API endpoint knowledge in one place, making future changes much easier.
