Axon BBS - Asset Loading Strategies for Large Applets
Version: 10.27.0
Date: 2025-10-15

=============================================================================
OVERVIEW
=============================================================================

This document outlines best practices for loading and managing assets in
Axon BBS applets. As applets grow in complexity, efficient asset loading
becomes critical for performance, memory usage, and user experience.

Three primary strategies are available:
1. Full Extraction (Simple) - Current HexGL implementation
2. Lazy Loading (On-Demand) - Load assets as needed
3. Hybrid Priority Loading (Recommended for large apps) - Best of both worlds

=============================================================================
STRATEGY 1: FULL EXTRACTION (SIMPLE)
=============================================================================

Description:
Extract the entire ZIP asset package into memory at startup. All assets are
immediately available as blob URLs.

When to Use:
- Small to medium asset packages (<50MB)
- Most/all assets needed before game starts
- Simple games with single level or scene
- Rapid prototyping and development

Current Implementation (HexGL):
```javascript
async function loadAssetPackage(hash, progressCallback) {
    const assetBlob = await window.bbs.getAttachmentBlob(hash);
    const zip = await JSZip.loadAsync(assetBlob);
    const assets = {};
    const promises = [];

    const filesInZip = Object.keys(zip.files).filter(name => !zip.files[name].dir);

    filesInZip.forEach((relativePath) => {
        const zipEntry = zip.files[relativePath];
        const promise = (zipEntry.name.endsWith('.js') ?
            zipEntry.async('string') :
            zipEntry.async('blob')
        ).then(content => {
            const objectURL = zipEntry.name.endsWith('.js') ?
                content :
                URL.createObjectURL(content);
            const fileName = relativePath.split('/').pop();
            assets[fileName] = objectURL;
        });
        promises.push(promise);
    });

    await Promise.all(promises);
    return assets;
}
```

Pros:
+ Simple implementation
+ Zero decompression overhead during gameplay
+ All assets immediately available
+ Predictable memory usage

Cons:
- Higher initial memory footprint
- Slower initial load time
- Wastes memory on unused assets
- Not scalable for very large games

Memory Profile:
- Initial spike: Full package size in RAM
- Steady state: All assets remain in memory
- Peak: 2x package size during extraction

Example Use Cases:
- HexGL racing game (20MB assets)
- Simple puzzle games
- Single-level arcade games
- UI-heavy applets

=============================================================================
STRATEGY 2: LAZY LOADING (ON-DEMAND)
=============================================================================

Description:
Load the ZIP index only at startup. Decompress individual assets on-demand
when requested. Implement LRU caching to balance memory and performance.

When to Use:
- Large asset packages (>100MB)
- Level-based games (load per level)
- Optional content (DLC, skins, mods)
- Memory-constrained environments

Implementation:
```javascript
class LazyAssetLoader {
    constructor() {
        this.zip = null;
        this.cache = new Map();
        this.cacheOrder = [];
        this.maxCacheSize = 50 * 1024 * 1024;  // 50MB
        this.currentCacheSize = 0;
    }

    async init(hash) {
        const assetBlob = await window.bbs.getAttachmentBlob(hash);
        // Only load ZIP directory structure, not file contents
        this.zip = await JSZip.loadAsync(assetBlob);
        console.log(`Loaded ZIP index with ${Object.keys(this.zip.files).length} files`);
    }

    async getAsset(filename) {
        // Check cache first
        if (this.cache.has(filename)) {
            // Move to end (most recently used)
            this.cacheOrder = this.cacheOrder.filter(f => f !== filename);
            this.cacheOrder.push(filename);
            return this.cache.get(filename);
        }

        // Decompress on-demand
        const zipEntry = this.zip.files[filename];
        if (!zipEntry) {
            throw new Error(`Asset not found: ${filename}`);
        }

        const content = await zipEntry.async('blob');
        const objectURL = URL.createObjectURL(content);
        const size = content.size;

        // Add to cache
        this.cache.set(filename, objectURL);
        this.cacheOrder.push(filename);
        this.currentCacheSize += size;

        // Evict old entries if needed
        while (this.currentCacheSize > this.maxCacheSize && this.cacheOrder.length > 1) {
            const oldestFile = this.cacheOrder.shift();
            const oldURL = this.cache.get(oldestFile);
            const oldEntry = this.zip.files[oldestFile];

            URL.revokeObjectURL(oldURL);
            this.cache.delete(oldestFile);

            // Estimate size (not always accurate, but close enough)
            const oldBlob = await oldEntry.async('blob');
            this.currentCacheSize -= oldBlob.size;
        }

        return objectURL;
    }

    // Clear cache when changing levels
    clearCache() {
        this.cacheOrder.forEach(filename => {
            URL.revokeObjectURL(this.cache.get(filename));
        });
        this.cache.clear();
        this.cacheOrder = [];
        this.currentCacheSize = 0;
    }
}
```

Usage:
```javascript
const loader = new LazyAssetLoader();
await loader.init(assetHash);

// Load texture on demand
const textureURL = await loader.getAsset('level1-floor.jpg');
const texture = textureLoader.load(textureURL);

// Clear cache when switching levels
loader.clearCache();
```

Pros:
+ Much lower initial memory usage
+ Faster startup (only load ZIP index)
+ Scalable to very large games
+ Memory-efficient for unused assets

Cons:
- Decompression overhead during gameplay (can cause stuttering)
- More complex implementation
- Requires careful cache management
- Harder to debug asset loading issues

Memory Profile:
- Initial: Only ZIP index (~1% of package size)
- Steady state: Cache size (configurable, e.g., 50MB)
- Peak: Cache size + largest single asset

Example Use Cases:
- Large open-world games
- Multi-level platformers
- Games with optional DLC content
- Applets with user-generated content

=============================================================================
STRATEGY 3: HYBRID PRIORITY LOADING (RECOMMENDED)
=============================================================================

Description:
Combine full extraction for critical assets with lazy loading for optional
content. Define asset priority levels and preload strategies.

When to Use:
- Medium to large games (50MB+)
- Games with distinct loading phases
- Need fast startup + efficient memory usage
- Best balance of performance and flexibility

Priority Levels:
1. CRITICAL - Load immediately, never evict (menus, core UI, loading screens)
2. HIGH - Preload on startup, low eviction priority (current level assets)
3. MEDIUM - Load on-demand, cache aggressively (nearby level assets)
4. LOW - Load on-demand, evict quickly (distant level assets, optional content)

Implementation:
```javascript
class HybridAssetLoader {
    constructor() {
        this.zip = null;
        this.criticalAssets = new Map();  // Never evicted
        this.cache = new Map();           // LRU cache
        this.cacheOrder = [];
        this.manifest = null;             // Asset priority manifest
        this.maxCacheSize = 75 * 1024 * 1024;  // 75MB cache
        this.currentCacheSize = 0;
        this.loadingQueue = [];
        this.isProcessingQueue = false;
    }

    async init(hash, manifestURL) {
        // Load asset manifest (defines priorities)
        const manifestResponse = await fetch(manifestURL);
        this.manifest = await manifestResponse.json();

        // Load ZIP index
        const assetBlob = await window.bbs.getAttachmentBlob(hash);
        this.zip = await JSZip.loadAsync(assetBlob);

        console.log(`Loaded ZIP with ${Object.keys(this.zip.files).length} files`);
        console.log(`Manifest defines ${this.manifest.critical.length} critical assets`);
    }

    async preloadCritical(progressCallback) {
        const criticalFiles = this.manifest.critical || [];
        let loaded = 0;

        for (const filename of criticalFiles) {
            const url = await this.extractAsset(filename);
            this.criticalAssets.set(filename, url);
            loaded++;
            progressCallback({
                status: `Loading critical: ${filename}`,
                percent: Math.round((loaded / criticalFiles.length) * 100)
            });
        }
    }

    async preloadHigh(progressCallback) {
        const highPriorityFiles = this.manifest.high || [];
        let loaded = 0;

        for (const filename of highPriorityFiles) {
            await this.getAsset(filename);  // Adds to cache
            loaded++;
            progressCallback({
                status: `Preloading: ${filename}`,
                percent: Math.round((loaded / highPriorityFiles.length) * 100)
            });
        }
    }

    async getAsset(filename) {
        // Check critical assets first (never evicted)
        if (this.criticalAssets.has(filename)) {
            return this.criticalAssets.get(filename);
        }

        // Check cache
        if (this.cache.has(filename)) {
            this.touchCache(filename);
            return this.cache.get(filename);
        }

        // Extract and cache
        const url = await this.extractAsset(filename);
        await this.addToCache(filename, url);
        return url;
    }

    async queueAsset(filename, priority = 'medium') {
        // Add to loading queue for background loading
        this.loadingQueue.push({ filename, priority });
        this.loadingQueue.sort((a, b) => {
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
        });

        if (!this.isProcessingQueue) {
            this.processQueue();
        }
    }

    async processQueue() {
        this.isProcessingQueue = true;

        while (this.loadingQueue.length > 0) {
            const { filename } = this.loadingQueue.shift();

            // Don't load if already cached
            if (!this.cache.has(filename) && !this.criticalAssets.has(filename)) {
                try {
                    await this.getAsset(filename);
                } catch (e) {
                    console.error(`Failed to preload ${filename}:`, e);
                }
            }

            // Yield to main thread
            await new Promise(resolve => setTimeout(resolve, 0));
        }

        this.isProcessingQueue = false;
    }

    async extractAsset(filename) {
        const zipEntry = this.zip.files[filename];
        if (!zipEntry) {
            throw new Error(`Asset not found: ${filename}`);
        }

        const isText = filename.endsWith('.js') || filename.endsWith('.json');
        const content = await zipEntry.async(isText ? 'string' : 'blob');

        if (isText) {
            return content;
        } else {
            return URL.createObjectURL(content);
        }
    }

    async addToCache(filename, url) {
        const zipEntry = this.zip.files[filename];
        const blob = await zipEntry.async('blob');
        const size = blob.size;

        this.cache.set(filename, url);
        this.cacheOrder.push(filename);
        this.currentCacheSize += size;

        // Get priority for this asset
        const priority = this.getAssetPriority(filename);

        // Evict LOW priority assets first, then MEDIUM
        while (this.currentCacheSize > this.maxCacheSize) {
            const evicted = this.evictAsset(['low', 'medium']);
            if (!evicted) break;  // No more evictable assets
        }
    }

    evictAsset(priorityLevels) {
        // Find oldest asset matching priority levels
        for (let i = 0; i < this.cacheOrder.length; i++) {
            const filename = this.cacheOrder[i];
            const priority = this.getAssetPriority(filename);

            if (priorityLevels.includes(priority)) {
                const url = this.cache.get(filename);
                URL.revokeObjectURL(url);
                this.cache.delete(filename);
                this.cacheOrder.splice(i, 1);

                // Update size (approximate)
                const zipEntry = this.zip.files[filename];
                zipEntry.async('blob').then(blob => {
                    this.currentCacheSize -= blob.size;
                });

                return true;
            }
        }
        return false;
    }

    getAssetPriority(filename) {
        if (this.manifest.critical.includes(filename)) return 'critical';
        if (this.manifest.high.includes(filename)) return 'high';
        if (this.manifest.medium.includes(filename)) return 'medium';
        return 'low';
    }

    touchCache(filename) {
        // Move to end (most recently used)
        const index = this.cacheOrder.indexOf(filename);
        if (index > -1) {
            this.cacheOrder.splice(index, 1);
            this.cacheOrder.push(filename);
        }
    }

    // Clear only non-critical cache when changing levels
    clearNonCriticalCache() {
        this.cacheOrder.forEach(filename => {
            const url = this.cache.get(filename);
            URL.revokeObjectURL(url);
        });
        this.cache.clear();
        this.cacheOrder = [];
        this.currentCacheSize = 0;
    }

    // Preload assets for next level in background
    async preloadLevel(levelName) {
        const levelAssets = this.manifest.levels[levelName] || [];
        levelAssets.forEach(filename => {
            this.queueAsset(filename, 'high');
        });
    }
}
```

Asset Manifest Format:
```json
{
  "critical": [
    "ui-background.jpg",
    "ui-buttons.png",
    "loading-spinner.gif",
    "menu-music.mp3"
  ],
  "high": [
    "level1-track.js",
    "level1-diffuse.jpg",
    "player-ship.js",
    "player-texture.png"
  ],
  "medium": [
    "level2-track.js",
    "level2-diffuse.jpg",
    "enemy-ship.js"
  ],
  "low": [
    "level3-track.js",
    "bonus-content.zip"
  ],
  "levels": {
    "level1": ["level1-track.js", "level1-diffuse.jpg"],
    "level2": ["level2-track.js", "level2-diffuse.jpg"],
    "level3": ["level3-track.js", "level3-diffuse.jpg"]
  }
}
```

Usage:
```javascript
// Initialize with asset package and manifest
const loader = new HybridAssetLoader();
await loader.init(assetHash, 'assets/manifest.json');

// Load critical assets (loading screen, UI)
await loader.preloadCritical(progressCallback);

// Show main menu
showMainMenu();

// Preload high-priority assets for level 1
await loader.preloadHigh(progressCallback);

// Start game
startGame();

// During gameplay, load assets on-demand
const texture = await loader.getAsset('enemy-texture.png');

// When approaching level 2, preload in background
loader.preloadLevel('level2');

// When entering level 2, clear level 1 cache
loader.clearNonCriticalCache();
await loader.preloadHigh(progressCallback);  // Load level 2 high-priority
```

Pros:
+ Fast startup (only critical assets)
+ Efficient memory usage (smart caching)
+ No gameplay stuttering (high-priority assets preloaded)
+ Scalable to very large games
+ Background loading for seamless transitions

Cons:
- Most complex implementation
- Requires asset manifest management
- Need careful priority tuning
- More testing required

Memory Profile:
- Initial: Critical assets only (~5-10MB)
- Steady state: Critical + cache (~75MB)
- Peak: Critical + cache + largest asset (~100MB)

Example Use Cases:
- Large racing games (HexGL with 10+ tracks)
- Multi-level adventure games
- Games with cutscenes and cinematics
- Professional-quality applets

=============================================================================
PERFORMANCE COMPARISON
=============================================================================

Test Case: 100MB Asset Package, 20MB Level Assets

Strategy          | Initial Load | Memory Peak | Gameplay FPS | Level Switch
------------------|--------------|-------------|--------------|-------------
Full Extraction   | 8.5s         | 200MB       | 60 FPS       | Instant
Lazy Loading      | 1.2s         | 75MB        | 45-60 FPS    | 0.5s
Hybrid Priority   | 2.5s         | 95MB        | 60 FPS       | 0.2s

Notes:
- Full Extraction: Best FPS but highest memory
- Lazy Loading: Best memory but inconsistent FPS
- Hybrid: Best balance of all metrics

=============================================================================
MIGRATION GUIDE
=============================================================================

Upgrading Existing Applet (e.g., HexGL):

Step 1: Create Asset Manifest
Create assets/manifest.json:
```json
{
  "critical": ["ui-sprites.png", "loading-bg.jpg"],
  "high": ["track.js", "feisar.js", "track-diffuse.jpg", "ship-texture.png"],
  "medium": ["bonus-models.js"],
  "low": []
}
```

Step 2: Replace Loader
Change from:
```javascript
const assets = await loadAssetPackage(hash, progressCallback);
```

To:
```javascript
const loader = new HybridAssetLoader();
await loader.init(hash, 'assets/manifest.json');
await loader.preloadCritical(progressCallback);
// Show loading screen
await loader.preloadHigh(progressCallback);
// Start game
```

Step 3: Update Asset Access
Change from:
```javascript
const texture = textureLoader.load(assets['track-diffuse.jpg']);
```

To:
```javascript
const textureURL = await loader.getAsset('track-diffuse.jpg');
const texture = textureLoader.load(textureURL);
```

Step 4: Add Background Preloading (Optional)
```javascript
// Preload next level while playing current level
loader.queueAsset('level2-track.js', 'medium');
```

=============================================================================
BEST PRACTICES
=============================================================================

1. Asset Organization:
   - Group assets by level/scene
   - Name files descriptively (level1-track.js, not track1.js)
   - Keep asset manifest in version control

2. Priority Assignment:
   - CRITICAL: Only UI and loading screens (<10MB total)
   - HIGH: Current level assets needed immediately
   - MEDIUM: Next level assets, optional effects
   - LOW: Distant content, easter eggs

3. Cache Sizing:
   - Rule of thumb: Cache = 1.5x largest level size
   - Monitor actual usage and adjust
   - Consider target platform (mobile vs desktop)

4. Background Loading:
   - Preload next level when 75% through current level
   - Use requestIdleCallback for background tasks
   - Monitor network bandwidth for federated assets

5. Memory Management:
   - Always revoke blob URLs when done
   - Clear cache between major transitions
   - Keep critical assets in memory permanently

6. Testing:
   - Test on low-memory devices (mobile)
   - Simulate slow networks
   - Profile memory usage with Chrome DevTools
   - Test cache eviction under pressure

=============================================================================
FUTURE ENHANCEMENTS
=============================================================================

Potential Improvements:

1. Streaming Decompression:
   - Use streaming APIs for very large files
   - Decompress chunks incrementally
   - Reduce memory spikes

2. Progressive Textures:
   - Load low-res textures first
   - Upgrade to high-res in background
   - Improve perceived load time

3. Smart Prefetching:
   - Predict player movement
   - Preload assets in player's direction
   - Machine learning for prediction

4. Federation-Aware Loading:
   - Check peer bandwidth before requesting assets
   - Cache assets from slow peers locally
   - Load-balance across multiple peers

5. Asset Compression:
   - Use modern formats (WebP, AVIF for images)
   - Compress models with Draco
   - Audio streaming with chunked formats

=============================================================================
REFERENCE IMPLEMENTATIONS
=============================================================================

Current Implementations:

1. HexGL (Full Extraction):
   Location: /home/dukejer/axon_bbs/frontend/src/applets/hexgl.js
   Lines: 84-120 (loadAssetPackage function)
   Use this as reference for simple asset loading

2. Future: Advanced Racing Game (Hybrid Priority):
   To be implemented using HybridAssetLoader class above

=============================================================================
SUPPORT & QUESTIONS
=============================================================================

For questions about asset loading strategies:
- Review HexGL implementation for working example
- Test different strategies with your asset package size
- Profile memory usage in Chrome DevTools
- Consider user experience vs complexity trade-offs

General guideline:
- <50MB assets: Use Full Extraction (Strategy 1)
- 50-200MB assets: Use Hybrid Priority (Strategy 3)
- >200MB assets: Use Lazy Loading (Strategy 2) or reconsider asset size

=============================================================================
VERSION HISTORY
=============================================================================

10.27.0 (2025-10-15):
- Initial documentation
- Defined three loading strategies
- Provided complete implementation examples
- Added performance comparison and migration guide
